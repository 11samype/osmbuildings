        function onResize(e) {
            setSize(e.width, e.height);
            render();
            loadData();
        }

        function onMove(e) {
            setOrigin(e.x, e.y);
            render();
        }

        function onMoveEnd(e) {
            var
                nw = pixelToGeo(originX,         originY),
                se = pixelToGeo(originX + width, originY + height)
            ;
            // check, whether viewport is still within loaded data bounding box
            if (meta && (nw[LAT] > meta.n || nw[LON] < meta.w || se[LAT] < meta.s || se[LON] > meta.e)) {
                loadData();
            }
        }

        function onZoomStart(e) {
            isZooming = true;
            render(); // effectively clears
        }

        function onZoomEnd(e) {
            isZooming = false;
            setZoom(e.zoom);
            if (!rawData) {
                loadData();
                return;
            }
            data = scaleData(rawData);
            render();
        }

        function onDataLoaded(res) {
            var
                i, il,
                resData, resMeta,
                keyList = [], k,
                offX = 0, offY = 0
            ;

            minZoom = MIN_ZOOM;
            req = null;

            // no response or response not matching current zoom (= too old response)
            if (!res || res.meta.z !== zoom) {
                return;
            }

            resMeta = res.meta;
            resData = res.data;

            // offset between old and new data set
            if (meta && data && meta.z === resMeta.z) {
                offX = meta.x - resMeta.x;
                offY = meta.y - resMeta.y;

                // identify already present buildings to fade in new ones
                for (i = 0, il = data.length; i < il; i++) {
                    // id key: x,y of first point - good enough
                    keyList[i] = (data[i][FOOTPRINT][0] + offX) + ',' + (data[i][FOOTPRINT][1] + offY);
                }
            }

            meta = resMeta;
            data = [];

            for (i = 0, il = resData.length; i < il; i++) {
                data[i] = resData[i];
                data[i][HEIGHT] = min(data[i][HEIGHT], MAX_HEIGHT);
                k = data[i][FOOTPRINT][0] + ',' + data[i][FOOTPRINT][1];
                data[i][IS_NEW] = !(keyList && ~keyList.indexOf(k));
            }

            resMeta = resData = keyList = null; // gc

            fadeIn();
        }
