<!DOCTYPE html>
<html>
<head>
<title>Dome</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body>
<canvas width="800" height="800">

<script>
var context = document.querySelector('CANVAS').getContext('2d');

var Debug = {
  point: function(x, y, color, size) {
    context.fillStyle = color || '#ffcc00';
    context.beginPath();
//  context.moveTo(x, y+(size || 5));
    context.arc(x, y, size || 5, 0, 2*Math.PI);
    context.closePath();
    context.fill();
  },
  line: function(ax, ay, bx, by, color) {
    context.strokeStyle = color || '#ffcc00';
    context.beginPath();
    context.moveTo(ax, ay);
    context.lineTo(bx, by);
    context.closePath();
    context.stroke();
  }
};

function unitVector(a, b) {
  var
    dx = a.x-b.x,
    dy = a.y-b.y,
    length = Math.sqrt(dx*dx + dy*dy);
  return {
    x: dx/length,
    y: dy/length
  };
}

function rotation(p, c, a) {
  var ms = Math.sin(a), mc = Math.cos(a);
  p.x -= c.x;
  p.y -= c.y;
  return {
    x: p.x* mc + p.y*ms + c.x,
    y: p.x*-ms + p.y*mc + c.y
  };
}

var KAPPA = 0.5522847498;

function halfCircle(c, v, r, h) {

  var _r = r * CAM_Z / (CAM_Z-h);

  var cv = c.y-v.y;

  context.strokeStyle = '#ff0000';
  context.beginPath();
  context.moveTo(c.x-r, c.y);
  context.bezierCurveTo(
    c.x - r, c.y - cv*KAPPA * h/cv,
    v.x - _r*KAPPA*1.2, v.y,
    v.x, v.y
  );
  context.stroke();

  context.beginPath();
  context.moveTo(c.x+r, c.y);
  context.bezierCurveTo(
    c.x + r, c.y - cv*KAPPA * h/cv,
    v.x + _r*KAPPA*1.2, v.y,
    v.x, v.y
  );
  context.stroke();
}


function dome(c, r, h, minHeight) {
  context.strokeStyle = '#666666';

  if (!h) {
    h = r;
  }

  minHeight = minHeight || 0;

  if (minHeight) {
    c = project(c, CAM_Z / (CAM_Z-minHeight));
    r *= CAM_Z / (CAM_Z-minHeight);
  }

  drawCircle(c, r, true);

context.beginPath();
var _h = CAM_Z / (CAM_Z-h);
var hfK = CAM_Z / (CAM_Z-(h*KAPPA));
var apex = project(c, _h);
for (var i = 0; i < 180; i+=5) {
  drawMeridian(c, r, _h, hfK, apex, i*RAD);
}
context.stroke();
  var v = getVanishingPoint(c, r, h, minHeight);

halfCircle(c, v, r, h);
/***
  var angle = Math.atan((CAM_X-c.x)/(CAM_Y-c.y));

  context.beginPath();
  context.moveTo(c.x, c.y+r);
  context.bezierCurveTo(
    c1.x, c1.x,
    c2.x, c2.x,
    v.x, v.y
  );
  context.stroke();

  context.beginPath();
  context.moveTo(c.x, c.y+r);
  context.bezierCurveTo(
    c1.x, c1.x,
    c2.x, c2.x,
    v.x, v.y
  );
  context.stroke();
***/

return;

  var angle = MAth.atan((CAM_X-c.x)/(CAM_Y-c.y));
  var scale = CAM_Z / (CAM_Z-v.y);

  var  p1h = rotation({ x:c.x-r, y:v.x }, c, angle);
  var _p1h = project(p1h, scale);

  var  p2h = rotation({ x:c.x+r, y:v.x }, c, angle);
  var _p2h = project(p2h, scale);






  var  ct1 = rotation({ x:t1.x, y:t1.y-KAPPA }, t1, angle);
  var _ct1 = project(ct1, scale);

  var  ct2 = rotation({ x:t2.x+r, y:t2.y-KAPPA }, t2, angle);
  var _ct2 = project(ct2, scale);






  context.beginPath();

  context.moveTo(p1v.x, p1v.y);
  context.bezierCurveTo(
    p1v.x + (_p1h.x-p1v.x) * KAPPA,
    p1v.y + (_p1h.y-p1v.y) * KAPPA,
    _p.x + (_p1h.x-_p.x) * KAPPA,
    _p.y + (_p1h.y-_p.y) * KAPPA,
    _p.x, _p.y);

  context.moveTo(p2v.x, p2v.y);
  context.bezierCurveTo(
    p2v.x + (_p2h.x-p2v.x) * KAPPA,
    p2v.y + (_p2h.y-p2v.y) * KAPPA,
    _p.x + (_p2h.x-_p.x) * KAPPA,
    _p.y + (_p2h.y-_p.y) * KAPPA,
    _p.x, _p.y);

//context.fill();
  context.stroke();


Debug.point(v.x, v.y, 'blue');
Debug.point(t1.x, t1.y, 'red');
Debug.point(t2.x, t2.y, 'green');

}

function drawMeridian(c, r, _h, hfK, apex, angle) {
  drawHalfMeridian(c, r, _h, hfK, apex, angle);
  drawHalfMeridian(c, r, _h, hfK, apex, angle + Math.PI);
}

function drawHalfMeridian(c, r, _h, hfK, apex, angle) {
  var
    p1 = rotation({ x:c.x, y:c.y-r },     c, angle),
    p2 = rotation({ x:c.x, y:c.y-r*KAPPA }, c, angle),
    _p1 = project(p1, hfK),
    _p2 = project(p2, _h);
  context.moveTo(p1.x, p1.y);
  context.bezierCurveTo(_p1.x, _p1.y, _p2.x, _p2.y, apex.x, apex.y);
}








// VERTICAL TANGENT POINTS ON SPHERE:
// side view at scenario:
// sphere at c.x,c.y & radius => circle at c.y,minHeight
// cam  at CAM_X/CAM_Y/CAM_Z => point  at CAM_Y/CAM_Z
function getVanishingPoint(c, r, h, minHeight) {
  var
    dx = CAM_X-c.x,
    dy = CAM_Y-c.y,
    d = Math.sqrt(dx*dx + dy*dy),
    v = getEllipseTangent(r, h, d, CAM_Z-minHeight),
    p = rotation({ x:c.x, y:c.y+v.x }, c, Math.atan(dx/dy));

  return project(p, CAM_Z / (CAM_Z-v.y));
}

function getEllipseTangent(a, b, x, y) {
  var
    C = (x*x) / (a*a) + (y*y) / (b*b),
    R = Math.sqrt(C-1),
    yabR = y*(a/b)*R,
    xbaR = x*(b/a)*R;
  return {
    x: (x + (  yabR < 0 ? yabR : -yabR)) / C,
    y: (y + (y+xbaR > 0 ? xbaR : -xbaR)) / C
  };
}

var RAD = Math.PI/180;
var WIDTH = 800;
var HEIGHT = 800;
var CAM_X = WIDTH/2;
var CAM_Y = HEIGHT;
var CAM_Z = 450;

document.addEventListener('mousemove', function(e) {
  context.clearRect(0, 0, WIDTH, HEIGHT);
  dome({ x:400, y:e.y }, 100, 100, 0);
  console.log(e.x, e.y);
});


function drawCircle(center, radius) {
  context.beginPath();
  context.arc(center.x, center.y, radius, 0, Math.PI*2);
  context.stroke();
//  context.fill();
}

function project(p, m) {
  return {
    x: (p.x-CAM_X) * m + CAM_X <<0,
    y: (p.y-CAM_Y) * m + CAM_Y <<0
  };
}

function getTangents(c1, r1, c2, r2) {
  var
    dx = c1.x-c2.x,
    dy = c1.y-c2.y,
    dr = r1-r2,
    sqdist = (dx*dx) + (dy*dy);

  if (sqdist <= dr*dr) {
    return;
  }

  var dist = Math.sqrt(sqdist),
    vx = -dx/dist,
    vy = -dy/dist,
    c  =  dr/dist,
    res = [],
    h, nx, ny;

  h = Math.sqrt(Math.max(0, 1 - c*c));
  for (var sign = 1; sign >= -1; sign -= 2) {
    nx = vx*c - sign*h*vy;
    ny = vy*c + sign*h*vx;
    res.push({
      x1: c1.x + r1*nx <<0,
      y1: c1.y + r1*ny <<0,
      x2: c2.x + r2*nx <<0,
      y2: c2.y + r2*ny <<0
    });
  }

  return res;
}

</script>
</body>
</html>